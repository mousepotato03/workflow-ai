/**
 * Connection management utilities for canvas edges
 */

import { CanvasNode, CanvasEdge, CanvasNodeType } from '@/types/canvas';

export interface ConnectionValidationResult {
  isValid: boolean;
  reason?: string;
}

/**
 * Validate if a connection between two nodes is allowed
 */
export function isConnectionValid(
  sourceNode: CanvasNode,
  targetNode: CanvasNode,
  existingEdges: CanvasEdge[] = []
): ConnectionValidationResult {
  // Prevent self-connections
  if (sourceNode.id === targetNode.id) {
    return {
      isValid: false,
      reason: "Cannot connect a node to itself"
    };
  }

  // Check if connection already exists
  const existingConnection = existingEdges.find(
    edge => edge.source === sourceNode.id && edge.target === targetNode.id
  );

  if (existingConnection) {
    return {
      isValid: false,
      reason: "Connection already exists between these nodes"
    };
  }

  // Check for reverse connection (to avoid bidirectional edges)
  const reverseConnection = existingEdges.find(
    edge => edge.source === targetNode.id && edge.target === sourceNode.id
  );

  if (reverseConnection) {
    return {
      isValid: false,
      reason: "A connection already exists in the opposite direction"
    };
  }

  // Validate based on node types
  const sourceType = sourceNode.type;
  const targetType = targetNode.type;

  // Main task can connect to subtasks
  if (sourceType === CanvasNodeType.MAIN_TASK && targetType === CanvasNodeType.SUBTASK) {
    return { isValid: true };
  }

  // Subtasks can connect to guides
  if (sourceType === CanvasNodeType.SUBTASK && targetType === CanvasNodeType.GUIDE_CARD) {
    return { isValid: true };
  }

  // Subtasks can connect to other subtasks
  if (sourceType === CanvasNodeType.SUBTASK && targetType === CanvasNodeType.SUBTASK) {
    return { isValid: true };
  }

  // Shape nodes can connect to anything
  if (sourceType === CanvasNodeType.RECTANGLE || 
      sourceType === CanvasNodeType.DIAMOND ||
      targetType === CanvasNodeType.RECTANGLE || 
      targetType === CanvasNodeType.DIAMOND) {
    return { isValid: true };
  }

  // Text nodes can connect to anything
  if (sourceType === CanvasNodeType.TEXT || targetType === CanvasNodeType.TEXT) {
    return { isValid: true };
  }

  return {
    isValid: false,
    reason: `Cannot connect ${sourceType} to ${targetType}`
  };
}

/**
 * Create workflow-specific connections between nodes
 */
export function createWorkflowConnections(nodes: CanvasNode[]): CanvasEdge[] {
  const connections: CanvasEdge[] = [];

  const mainTaskNodes = nodes.filter(n => n.type === CanvasNodeType.MAIN_TASK);
  const subtaskNodes = nodes.filter(n => n.type === CanvasNodeType.SUBTASK);
  const guideNodes = nodes.filter(n => n.type === CanvasNodeType.GUIDE_CARD);

  // Connect main task to all subtasks
  mainTaskNodes.forEach(mainTask => {
    subtaskNodes.forEach(subtask => {
      connections.push({
        id: `${mainTask.id}-${subtask.id}`,
        source: mainTask.id,
        target: subtask.id,
        type: 'smoothstep',
        animated: false,
        isAutoGenerated: true,
        style: { strokeWidth: 2, stroke: '#6366f1' }
      });
    });
  });

  // Connect subtasks to their guide cards
  guideNodes.forEach(guide => {
    if (guide.data && guide.type === CanvasNodeType.GUIDE_CARD) {
      const guideData = guide.data as any; // Type assertion to access associatedSubtaskId
      const associatedSubtask = subtaskNodes.find(
        subtask => subtask.id === guideData.associatedSubtaskId
      );

      if (associatedSubtask) {
        connections.push({
          id: `${associatedSubtask.id}-${guide.id}`,
          source: associatedSubtask.id,
          target: guide.id,
          type: 'smoothstep',
          animated: true,
          isAutoGenerated: true,
          label: 'guide',
          style: { strokeWidth: 2, stroke: '#10b981', strokeDasharray: '5,5' }
        });
      }
    }
  });

  return connections;
}

/**
 * Calculate optimal connection style based on node types
 */
export function getConnectionStyle(
  sourceNode: CanvasNode,
  targetNode: CanvasNode
): Partial<CanvasEdge> {
  const sourceType = sourceNode.type;
  const targetType = targetNode.type;

  // Main task to subtask connections
  if (sourceType === CanvasNodeType.MAIN_TASK && targetType === CanvasNodeType.SUBTASK) {
    return {
      type: 'smoothstep',
      animated: false,
      style: { 
        strokeWidth: 2, 
        stroke: '#6366f1' 
      }
    };
  }

  // Subtask to guide connections
  if (sourceType === CanvasNodeType.SUBTASK && targetType === CanvasNodeType.GUIDE_CARD) {
    return {
      type: 'smoothstep',
      animated: true,
      style: { 
        strokeWidth: 2, 
        stroke: '#10b981',
        strokeDasharray: '5,5'
      },
      label: 'guide'
    };
  }

  // Subtask to subtask connections
  if (sourceType === CanvasNodeType.SUBTASK && targetType === CanvasNodeType.SUBTASK) {
    return {
      type: 'smoothstep',
      animated: false,
      style: { 
        strokeWidth: 2, 
        stroke: '#8b5cf6' 
      }
    };
  }

  // Default connection style
  return {
    type: 'smoothstep',
    animated: false,
    style: { 
      strokeWidth: 1, 
      stroke: '#64748b' 
    }
  };
}

/**
 * Auto-connect related nodes based on workflow logic
 */
export function autoConnectNodes(nodes: CanvasNode[]): CanvasEdge[] {
  const edges: CanvasEdge[] = [];

  // Create workflow connections
  edges.push(...createWorkflowConnections(nodes));

  return edges;
}

/**
 * Connection utilities
 */
export const ConnectionUtils = {
  /**
   * Generate a unique edge ID
   */
  generateEdgeId: (sourceId: string, targetId: string): string => {
    return `edge-${sourceId}-${targetId}`;
  },

  /**
   * Check if edge exists
   */
  edgeExists: (sourceId: string, targetId: string, edges: CanvasEdge[]): boolean => {
    return edges.some(edge => edge.source === sourceId && edge.target === targetId);
  },

  /**
   * Get all edges connected to a node
   */
  getNodeEdges: (nodeId: string, edges: CanvasEdge[]): CanvasEdge[] => {
    return edges.filter(edge => edge.source === nodeId || edge.target === nodeId);
  },

  /**
   * Remove all edges connected to a node
   */
  removeNodeEdges: (nodeId: string, edges: CanvasEdge[]): CanvasEdge[] => {
    return edges.filter(edge => edge.source !== nodeId && edge.target !== nodeId);
  }
};