-- Add rag_knowledge_chunks table for RAG-based knowledge storage
-- This table stores processed document chunks with embeddings for enhanced tool matching

BEGIN;

-- Create rag_knowledge_chunks table
CREATE TABLE IF NOT EXISTS public.rag_knowledge_chunks (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  
  -- Link to the tool this knowledge is about
  tool_id uuid NOT NULL REFERENCES public.tools(id) ON DELETE CASCADE,
  
  -- Source information
  source_type text NOT NULL CHECK (source_type IN ('pdf', 'url', 'text', 'markdown')),
  source_path text, -- Original file path or URL
  source_title text, -- Document title or identifier
  source_metadata jsonb DEFAULT '{}', -- Additional metadata (file size, author, etc.)
  
  -- Chunk information
  chunk_index integer NOT NULL, -- Order of this chunk within the source
  content text NOT NULL CHECK (char_length(content) >= 10), -- The actual text content
  content_hash text NOT NULL, -- Hash of content for deduplication
  chunk_size integer NOT NULL DEFAULT 0, -- Character count
  
  -- Vector embedding for similarity search
  embedding vector, -- Generated by Google AI embedding model
  
  -- Processing metadata
  processed_at timestamptz DEFAULT now(),
  processing_version text DEFAULT '1.0', -- Track processing pipeline version
  
  -- Quality and relevance scores
  relevance_score float DEFAULT NULL, -- How relevant this chunk is to the tool
  quality_score float DEFAULT NULL, -- Content quality assessment
  
  -- Status and flags
  is_active boolean DEFAULT true,
  
  UNIQUE(tool_id, content_hash) -- Prevent duplicate content for the same tool
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_rag_chunks_tool_id ON public.rag_knowledge_chunks(tool_id);
CREATE INDEX IF NOT EXISTS idx_rag_chunks_source_type ON public.rag_knowledge_chunks(source_type);
CREATE INDEX IF NOT EXISTS idx_rag_chunks_active ON public.rag_knowledge_chunks(is_active) WHERE is_active = true;
CREATE INDEX IF NOT EXISTS idx_rag_chunks_content_hash ON public.rag_knowledge_chunks(content_hash);
CREATE INDEX IF NOT EXISTS idx_rag_chunks_created_at ON public.rag_knowledge_chunks(created_at DESC);

-- Vector similarity search index
CREATE INDEX IF NOT EXISTS idx_rag_chunks_embedding_cosine 
  ON public.rag_knowledge_chunks USING ivfflat (embedding vector_cosine_ops) WITH (lists='100');

-- Full-text search index for content
CREATE INDEX IF NOT EXISTS idx_rag_chunks_content_gin 
  ON public.rag_knowledge_chunks USING gin (to_tsvector('english', content));

-- Composite index for efficient tool-specific queries
CREATE INDEX IF NOT EXISTS idx_rag_chunks_tool_active_embedding 
  ON public.rag_knowledge_chunks(tool_id, is_active) WHERE is_active = true AND embedding IS NOT NULL;

-- Updated_at trigger
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger t JOIN pg_class c ON t.tgrelid = c.oid
    WHERE t.tgname = 'update_rag_knowledge_chunks_updated_at' AND c.relname = 'rag_knowledge_chunks'
  ) THEN
    CREATE TRIGGER update_rag_knowledge_chunks_updated_at
      BEFORE UPDATE ON public.rag_knowledge_chunks
      FOR EACH ROW
      EXECUTE FUNCTION public.update_updated_at_column();
  END IF;
END $$;

-- RLS policies (read access for authenticated users, write access for service role)
ALTER TABLE public.rag_knowledge_chunks ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Public can read active rag chunks" ON public.rag_knowledge_chunks;
CREATE POLICY "Public can read active rag chunks" 
  ON public.rag_knowledge_chunks FOR SELECT 
  USING (is_active = true);

DROP POLICY IF EXISTS "Service role can manage rag chunks" ON public.rag_knowledge_chunks;
CREATE POLICY "Service role can manage rag chunks" 
  ON public.rag_knowledge_chunks FOR ALL 
  USING (true) WITH CHECK (true);

-- Create function for similarity search
CREATE OR REPLACE FUNCTION public.match_rag_knowledge_chunks(
  query_embedding vector,
  tool_ids uuid[] DEFAULT NULL,
  match_threshold float DEFAULT 0.78,
  match_count int DEFAULT 10
)
RETURNS TABLE (
  id uuid,
  tool_id uuid,
  content text,
  source_title text,
  source_type text,
  relevance_score float,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    rkc.id,
    rkc.tool_id,
    rkc.content,
    rkc.source_title,
    rkc.source_type,
    rkc.relevance_score,
    (1 - (rkc.embedding <=> query_embedding)) AS similarity
  FROM public.rag_knowledge_chunks rkc
  WHERE
    rkc.is_active = true
    AND rkc.embedding IS NOT NULL
    AND (tool_ids IS NULL OR rkc.tool_id = ANY(tool_ids))
    AND (1 - (rkc.embedding <=> query_embedding)) > match_threshold
  ORDER BY rkc.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Create function to get knowledge chunks for specific tools
CREATE OR REPLACE FUNCTION public.get_tool_knowledge_summary(
  input_tool_id uuid,
  max_chunks int DEFAULT 5
)
RETURNS TABLE (
  chunk_count bigint,
  sources jsonb,
  top_chunks jsonb
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  WITH chunk_stats AS (
    SELECT 
      COUNT(*) as total_chunks,
      jsonb_agg(DISTINCT jsonb_build_object(
        'source_type', rkc.source_type,
        'source_title', rkc.source_title,
        'chunk_count', COUNT(*) OVER (PARTITION BY rkc.source_title)
      )) as source_info
    FROM public.rag_knowledge_chunks rkc
    WHERE rkc.tool_id = input_tool_id AND rkc.is_active = true
  ),
  top_content AS (
    SELECT jsonb_agg(
      jsonb_build_object(
        'content', LEFT(rkc.content, 200) || CASE WHEN LENGTH(rkc.content) > 200 THEN '...' ELSE '' END,
        'source_title', rkc.source_title,
        'relevance_score', rkc.relevance_score
      )
    ) as chunks
    FROM (
      SELECT rkc.content, rkc.source_title, rkc.relevance_score
      FROM public.rag_knowledge_chunks rkc
      WHERE rkc.tool_id = input_tool_id AND rkc.is_active = true
      ORDER BY rkc.relevance_score DESC NULLS LAST, rkc.created_at DESC
      LIMIT max_chunks
    ) rkc
  )
  SELECT 
    cs.total_chunks,
    cs.source_info,
    tc.chunks
  FROM chunk_stats cs
  CROSS JOIN top_content tc;
END;
$$;

COMMIT;